/**
 * Solitaire (Klondike)
 * Classic Windows XP style Solitaire
 */

class Solitaire {
    constructor() {
        this.windowManager = null;
        this.windowId = null;
        this.deck = [];
        this.piles = {
            tableau: [[], [], [], [], [], [], []],
            foundation: [[], [], [], []],
            stock: [],
            waste: []
        };
        this.draggedCard = null;
        this.score = 0;
        this.time = 0;
        this.timerInterval = null;
    }

    init(windowManager) {
        this.windowManager = windowManager;
    }

    open() {
        if (!this.windowManager) return;

        const win = this.windowManager.createWindow({
            title: 'Solitaire',
            width: 800,
            height: 600,
            resizable: true,
            icon: 'üÉè',
            content: this.createHTML()
        });

        this.windowId = win.id;
        this.setupGame();
        this.setupEventListeners(win.element);
        
        // Remove default padding
        const content = win.element.querySelector('.window-content');
        if (content) {
            content.style.padding = '0';
            content.style.background = '#008000';
            content.style.overflow = 'hidden';
        }

        return win;
    }

    createHTML() {
        return `
            <div class="solitaire-container" style="
                display: flex; 
                flex-direction: column; 
                height: 100%; 
                background: #008000;
                font-family: 'Tahoma', sans-serif;
                user-select: none;
            ">
                <!-- Status Bar -->
                <div class="sol-status" style="
                    height: 24px;
                    background: #fff;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 0 10px;
                    font-size: 11px;
                    border-bottom: 1px solid #808080;
                ">
                    <div>Score: <span id="sol-score">0</span></div>
                    <div>Time: <span id="sol-time">0</span></div>
                </div>

                <!-- Game Area -->
                <div class="sol-game-area" style="
                    flex: 1; 
                    position: relative; 
                    padding: 20px;
                ">
                    <!-- Socket for Stock/Waste (Top Left) -->
                    <div style="display: flex; gap: 20px; position: absolute; left: 20px; top: 20px;">
                        <div id="sol-stock" class="card-slot empty"></div>
                        <div id="sol-waste" class="card-slot empty"></div>
                    </div>

                    <!-- Socket for Foundation (Top Right) -->
                    <div style="display: flex; gap: 10px; position: absolute; right: 20px; top: 20px;">
                        <div id="sol-fnd-0" class="card-slot foundation empty" data-type="foundation" data-idx="0"></div>
                        <div id="sol-fnd-1" class="card-slot foundation empty" data-type="foundation" data-idx="1"></div>
                        <div id="sol-fnd-2" class="card-slot foundation empty" data-type="foundation" data-idx="2"></div>
                        <div id="sol-fnd-3" class="card-slot foundation empty" data-type="foundation" data-idx="3"></div>
                    </div>

                    <!-- Tableau (Bottom) -->
                    <div id="sol-tableau" style="
                        display: flex; 
                        gap: 15px; /* reduced gap to fit 7 columns */
                        position: absolute; 
                        top: 150px; 
                        left: 20px;
                        width: calc(100% - 40px);
                        justify-content: space-between;
                    ">
                        <!-- 7 Columns generated by JS -->
                    </div>
                </div>
                
                <style>
                    .card-slot {
                        width: 71px;
                        height: 96px;
                        border: 1px solid #004d00;
                        border-radius: 4px;
                        position: relative;
                    }
                    .card-slot.empty {
                        border: 1px solid rgba(255,255,255,0.2);
                        background: rgba(0,0,0,0.1);
                    }
                    .sol-card {
                        width: 71px;
                        height: 96px;
                        background: white;
                        border: 1px solid #808080;
                        border-radius: 4px;
                        box-shadow: 1px 1px 2px rgba(0,0,0,0.3);
                        position: absolute;
                        cursor: pointer;
                        display: flex;
                        flex-direction: column;
                        justify-content: space-between;
                        padding: 4px;
                        box-sizing: border-box;
                        font-size: 14px;
                        font-weight: bold;
                    }
                    .sol-card.red { color: red; }
                    .sol-card.black { color: black; }
                    .sol-card-back {
                        background: repeating-linear-gradient(
                            45deg,
                            #606dbc,
                            #606dbc 10px,
                            #465298 10px,
                            #465298 20px
                        );
                        border: 2px solid white;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    }
                    .sol-card-back::after {
                        content: 'ü§ñ'; /* Robot theme instead of beach */
                        font-size: 32px;
                        opacity: 0.5;
                    }
                    .tableau-col {
                        width: 71px;
                        min-height: 100px;
                        position: relative;
                    }
                </style>
            </div>
        `;
    }

    setupGame() {
        this.deck = this.createDeck();
        this.shuffleDeck(this.deck);
        
        // Clear state
        this.piles.tableau = [[], [], [], [], [], [], []];
        this.piles.foundation = [[], [], [], []];
        this.piles.stock = [];
        this.piles.waste = [];
        this.score = 0;
        this.time = 0;
        if (this.timerInterval) clearInterval(this.timerInterval);

        // Deal
        let cardIdx = 0;
        for (let i = 0; i < 7; i++) {
            for (let j = 0; j <= i; j++) {
                const card = this.deck[cardIdx++];
                if (j === i) card.faceUp = true;
                else card.faceUp = false;
                this.piles.tableau[i].push(card);
            }
        }

        // Rest to stock
        while (cardIdx < 52) {
            this.piles.stock.push(this.deck[cardIdx++]);
        }

        this.startTimer();
        this.render();
    }

    createDeck() {
        const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
        const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const deck = [];
        
        suits.forEach(suit => {
            values.forEach((value, index) => {
                deck.push({
                    suit,
                    value,
                    rank: index + 1, // 1-13
                    color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                    faceUp: false,
                    id: Math.random().toString(36).substr(2, 9)
                });
            });
        });
        return deck;
    }

    shuffleDeck(deck) {
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
    }

    render() {
        const win = document.getElementById(this.windowId);
        if (!win) return;

        // Render Score & Time
        win.querySelector('#sol-score').textContent = this.score;
        win.querySelector('#sol-time').textContent = this.time;

        // Render Stock
        const stockEl = win.querySelector('#sol-stock');
        stockEl.innerHTML = '';
        if (this.piles.stock.length > 0) {
            const cardEl = this.createCardElement({ faceUp: false }); // Face down
            cardEl.onclick = () => this.drawCard();
            stockEl.appendChild(cardEl);
        } else {
            // Empty stock - click to reset from waste?
            const emptyEl = document.createElement('div');
            emptyEl.style.cssText = 'width:100%; height:100%; cursor:pointer; display:flex; justify-content:center; align-items:center; color:rgba(255,255,255,0.5); font-size:24px;';
            emptyEl.textContent = '‚Ü∫';
            emptyEl.onclick = () => this.recycleWaste();
            stockEl.appendChild(emptyEl);
        }

        // Render Waste
        const wasteEl = win.querySelector('#sol-waste');
        wasteEl.innerHTML = '';
        const wasteLen = this.piles.waste.length;
        if (wasteLen > 0) {
            // Show up to 3 cards
            const startIndex = Math.max(0, wasteLen - 3);
            for (let i = startIndex; i < wasteLen; i++) {
                const card = this.piles.waste[i];
                card.faceUp = true;
                const cardEl = this.createCardElement(card);
                
                const offset = (i - startIndex) * 20; 
                cardEl.style.position = 'absolute';
                cardEl.style.left = `${offset}px`;
                cardEl.style.top = '0';
                cardEl.style.zIndex = i;
                
                // Only top card clickable
                if (i === wasteLen - 1) {
                    cardEl.onclick = (e) => this.handleCardClick(card, 'waste');
                } else {
                    cardEl.style.cursor = 'default';
                    cardEl.onclick = (e) => e.stopPropagation();
                }
                
                wasteEl.appendChild(cardEl);
            }
        }

        // Render Foundations
        this.piles.foundation.forEach((pile, idx) => {
            const el = win.querySelector(`#sol-fnd-${idx}`);
            el.innerHTML = '';
            // Add placeholder icon if empty
            if (pile.length === 0) {
                el.textContent = 'A';
                el.style.color = 'rgba(255,255,255,0.3)';
                el.style.display = 'flex';
                el.style.justifyContent = 'center';
                el.style.alignItems = 'center';
                el.style.fontSize = '32px';
            } else {
                const topCard = pile[pile.length - 1];
                const cardEl = this.createCardElement(topCard);
                el.appendChild(cardEl);
            }
            // Click handler for foundation to put cards there? handled by source usually
            el.onclick = () => this.handleFoundationClick(idx);
        });

        // Render Tableau
        const tableauContainer = win.querySelector('#sol-tableau');
        tableauContainer.innerHTML = '';
        
        this.piles.tableau.forEach((col, colIdx) => {
            const colEl = document.createElement('div');
            colEl.className = 'tableau-col';
            colEl.dataset.col = colIdx;
            
            col.forEach((card, cardIdx) => {
                const cardEl = this.createCardElement(card);
                cardEl.style.position = 'absolute';
                cardEl.style.top = `${cardIdx * 15}px`; // Cascade
                // cardEl.style.zIndex = cardIdx; // Auto by order
                
                cardEl.onclick = (e) => {
                    e.stopPropagation();
                    this.handleCardClick(card, 'tableau', colIdx, cardIdx);
                };

                colEl.appendChild(cardEl);
            });

            // Click on empty column
            colEl.onclick = () => this.handleTableauClick(colIdx);

            tableauContainer.appendChild(colEl);
        });
    }

    createCardElement(card) {
        const el = document.createElement('div');
        if (!card.faceUp) {
            el.className = 'sol-card sol-card-back';
        } else {
            el.className = `sol-card ${card.color}`;
            
            const suitIcons = { hearts: '‚ô•', diamonds: '‚ô¶', clubs: '‚ô£', spades: '‚ô†' };
            const icon = suitIcons[card.suit];
            
            el.innerHTML = `
                <div style="font-size: 16px; display: flex; flex-direction: column; align-items: center; width: 15px;">
                    <span>${card.value}</span>
                    <span>${icon}</span>
                </div>
                <div style="font-size: 42px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0.2;">
                    ${icon}
                </div>
                <div style="font-size: 16px; transform: rotate(180deg); display: flex; flex-direction: column; align-items: center; width: 15px; align-self: flex-end;">
                    <span>${card.value}</span>
                    <span>${icon}</span>
                </div>
            `;
            
            if (this.selectedCard && this.selectedCard.card.id === card.id) {
                el.style.border = '2px solid yellow';
                el.style.backgroundColor = '#ffffdd';
            }
        }
        return el;
    }

    // Logic

    drawCard() {
        if (this.piles.stock.length === 0) return;
        
        let count = 0;
        while (count < 3 && this.piles.stock.length > 0) {
            const card = this.piles.stock.pop();
            card.faceUp = true;
            this.piles.waste.push(card);
            count++;
        }

        this.selectedCard = null; // Deselect on draw
        this.render();
    }

    recycleWaste() {
        if (this.piles.waste.length === 0) return;
        // Move waste back to stock, reverse order, face down
        while (this.piles.waste.length > 0) {
            const card = this.piles.waste.pop();
            card.faceUp = false;
            this.piles.stock.push(card);
        }
        this.score = Math.max(0, this.score - 100); // Penalty
        this.render();
    }

    handleCardClick(card, location, colIdx, cardIdx) {
        // If face down in tableau, do nothing (should be handled by logic to flip if exposed)
        if (!card.faceUp) {
            // Can only flip if it is the top card (last in array)
            if (location === 'tableau') {
                const pile = this.piles.tableau[colIdx];
                if (cardIdx === pile.length - 1) {
                    card.faceUp = true;
                    this.score += 5;
                    this.render();
                }
            }
            return;
        }

        // Selection Logic
        if (!this.selectedCard) {
            this.selectedCard = { card, location, colIdx, cardIdx };
            this.render();
        } else {
            // Try to move selected card to this card
            const target = { card, location, colIdx, cardIdx };
            
            if (this.selectedCard.card.id === target.card.id) {
                // Clicked same card - deselect
                this.selectedCard = null;
                this.render();
                return;
            }
            
            // Try move
            this.attemptMove(this.selectedCard, target);
        }
    }

    handleTableauClick(colIdx) {
        // Move to empty column
        if (this.selectedCard) {
            // Only King can go to empty column
            if (this.selectedCard.card.rank === 13) {
                 this.executeMove(this.selectedCard, { location: 'tableau', colIdx });
            }
        }
    }

    handleFoundationClick(idx) {
        if (this.selectedCard) {
            const card = this.selectedCard.card;
            const pile = this.piles.foundation[idx];
            
            // Ace on empty, or +1 same suit
            let valid = false;
            if (pile.length === 0) {
                if (card.rank === 1) valid = true;
            } else {
                const top = pile[pile.length - 1];
                if (top.suit === card.suit && card.rank === top.rank + 1) valid = true;
            }

            if (valid) {
                // Can only move 1 card to foundation at a time
                // If moving from tableau, ensure it's the last card
                if (this.selectedCard.location === 'tableau') {
                    const tCol = this.piles.tableau[this.selectedCard.colIdx];
                    if (this.selectedCard.cardIdx !== tCol.length - 1) return; // Not top card
                }
                
                this.executeMove(this.selectedCard, { location: 'foundation', idx });
            }
        }
    }

    attemptMove(source, target) {
        // Source is currently selected card
        // Target is where we clicked
        
        let valid = false;

        // Tableau to Tableau
        if (target.location === 'tableau') {
            const targetCard = target.card;
            const sourceCard = source.card;
            
            // Alternate color and -1 rank
            if (sourceCard.color !== targetCard.color && sourceCard.rank === targetCard.rank - 1) {
                // Determine if we are moving a stack
                valid = true;
            }
        }

        if (valid) {
            this.executeMove(source, target);
        } else {
            // Invalid move, change selection to new card? Or just deselect?
            // Windows behavior: clicking another card selects it.
            // But if it's invalid move, select the new one.
            // Check if target is selectable (face up)
            if (target.card.faceUp) {
                this.selectedCard = target;
                this.render();
            } else {
                this.selectedCard = null;
                this.render();
            }
        }
    }

    executeMove(source, target) {
        let cardsToMove = [];
        
        // Remove from source
        if (source.location === 'waste') {
            cardsToMove.push(this.piles.waste.pop());
        } else if (source.location === 'tableau') {
            const col = this.piles.tableau[source.colIdx];
            cardsToMove = col.splice(source.cardIdx); // Gets card and all below it
        }

        // Add to target
        if (target.location === 'tableau') {
            this.piles.tableau[target.colIdx].push(...cardsToMove);
        } else if (target.location === 'foundation') {
            this.piles.foundation[target.idx].push(cardsToMove[0]);
            this.score += 10;
        }

        this.selectedCard = null;
        this.render();
        this.checkWin();
    }

    startTimer() {
        this.timerInterval = setInterval(() => {
            this.time++;
            const win = document.getElementById(this.windowId);
            if (win) win.querySelector('#sol-time').textContent = this.time;
        }, 1000);
    }
    
    setupEventListeners(element) {
        // Double click to auto-move to foundation?
        // Could be added later
    }

    checkWin() {
        const totalFoundation = this.piles.foundation.reduce((acc, pile) => acc + pile.length, 0);
        if (totalFoundation === 52) {
            setTimeout(() => alert('You Won!'), 100);
            clearInterval(this.timerInterval);
        }
    }
}

export const solitaire = new Solitaire();
